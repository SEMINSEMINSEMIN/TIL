## 함수 구조
### 파선아실
파라미터: 함수 내부에서 선언된 변수
아규먼트: 실행될 때
```javascript
function 안녕(파라미터){
    console.log(파라미터);
    return 100;
}

let 아규먼트 = 1000;

안녕(아규먼트);
// 1000 (콘솔)
// 100

안녕(아규먼트) + 안녕(아규먼트); 
// 1000 (콘솔)
// 1000 (콘솔)
// 200

let arg = 안녕(아규먼트);
arg; // 100
arg + arg; // 200
```
### 리턴 값 생략시: undefined
```javascript
function 함수(){
    1 + 1;
}
함수(); // undefined
함수() + 함수(); // NaN
String(함수()) + String(함수()); // 'undefinedundefined'
```
console.log의 리턴 값은 undefined이다.
```javascript
function 함수(a, b){
    let c = a + b;
    return console.log(c);
}

let var1 = 함수(2, 2);
var1; // undefined
var1 + var1; // NaN
```
### return 뒤에 아무것도 입력하지 않을 경우
리턴 값 생략과 마찬가지로 undefined
```javascript
function 함수() {
    return;
} 

함수(); // undefined
```
### return은 데이터를 반환하고 함수를 종료한다
```javascript
function 안녕(특정조건){
    console.log('hello');
    console.log('hello');
    console.log('hello');
    if (특정조건){
        return 100;
    } else {
        console.log('world');
        console.log('world');
        return 200;
    }
    return 300;
}

안녕(true);
// hello
// hello
// hello
// 100

안녕(false);
// hello
// hello
// hello
// world
// world
// 200

안녕();
// hello
// hello
// hello
// world
// world
// 200
```
## 함수를 사용하는 이유
1. 재사용성
2. 유지보수(구조 파악 용이, 변수의 스코프
3. 구조 파악 용이
4. 추상화로 개발하는 것이 객체지향 프로그래밍 언어의 언어 철학. 기능을 몰라도 사용(자동차 브레이크 페달의 원리를 몰라도 걍 밟으면 브레이크 가능)

## 아규먼트의 수와 구조 분해 할당
### 필요 이상의 아규먼트
```javascript
function sum(a, b, c){
    return a + b + c;
}

sum(10, 20, 30, 40); // 60
```
### 필요 이하의 아규먼트
```javascript
function sum(a, b, c){
    return a + b + c;
}

sum(10, 20);
// NaN
```
NaN이 나온 이유: 10 + 20 + undefined
### 구조분해할당
```javascript
function sum([a, b], ...c){
    console.log(a);
    console.log(b);
    console.log(c);
}

sum([1, 2], 3, 4, 5);
// 1
// 2
// (3) [3, 4, 5]
// undefined
```
```javascript
function maxMinSum(...x){
    let max = Math.max(...x);
    let min = Math.min(...x);
    return max + min;
}

maxMinSum(1, 2, 3, 4, 5); // 6
```
## 함수 기본값
```javascript
function 함수(a = 10, b = 20, c = 30){
    return a + b + c;
}

함수(); // 60
함수(0); // 50
함수(30, 30); // 90
함수(1, 2, 3); // 6

// 아규먼트를 c = 1000 이런식으로 해도 '순서대로' 적용된다
함수(c=2000); // 2050
함수(c=1000, a=3000); // 4030
```
## 객체를 아규먼트로
구조분해할당 활용
```javascript
function BMI({
    이름,
    신장,
    몸무게
}){
    let BMI = 몸무게 / ((신장/100) ** 2);
    console.log(BMI);
    if (BMI >= 25.0) {
        return `${이름}님은 비만입니다.`;
    } else if (BMI >= 23.0) {
        return `${이름}님은 과체중입니다.`;
    } else if (BMI >= 18.5) {
        return `${이름}님은 정상입니다.`;
    } else {
        return `${이름}님은 저체중입니다.`;
    }
}

let stu1 = {이름: '홍길동', 신장: 178, 몸무게: 70};
BMI(stu1);
// 22.093170054286073
// '홍길동님은 저체중입니다.'

let stu2 = {이름: '아무개', 신장: 150, 몸무게: 60};
BMI(stu2);
// 26.666666666666668
// '아무개님은 비만입니다.'

// 입력하지 않은 거에 대해서는 undefined
let stu3 = {신장: 160, 몸무게: 55};
BMI(stu3);
// 21.484374999999996
// 'undefined님은 정상입니다.'
```
초기값
```javascript
// 이 코드는 실행되지 않는다
// 구조분해할당이 제대로 이루어지지 않음
function sum({a = 2, b = 1, c = 3}){
    return a + b + c;
}

sum(); // Uncaught TypeError: Cannot read properties of undefined (reading 'a')
```
```javascript
function sum({a = 2, b = 1, c = 3}={}){
    return a + b + c;
}
sum(); // 6
```
```javascript
function sum({a = 2, b = 1, c = 3}){
    return a + b + c;
}
sum({}); // 6
```
## 재귀함수
재귀함수(top-down: 위에서 아래로)

반복문(Bottom-up: 아래에서 위로)

반복문보다 재귀함수가 성능이 거의 떨어지긴 함
### 팩토리얼
```javascript
let result = 1;
for (let i = 1; i < 6; i++){
    result *= i;
}
result; // 120
```
```javascript
function factorial(n){
    if (n <= 1){ // 종료 조건
        return 1;
    }
    return n * factorial(n - 1); // 종료 조건이 없으면 무한 반복
}

factorial(5); // 120
```
|factorial(n)|n <= 1|return|
|:---:|:---:|:---:|
|factorial(5)|false|5 * factorial(4)|
|factorial(4)|false|4 * factorial(3)|
|factorial(3)|false|3 * factorial(2)|
|factorial(2)|false|2 * factorial(1)|
|factorial(1)|true|1|
### 시그마
```javascript
let sum = 0;
for (i = 1; i < 11; i++){
    sum+= i;
}
sum; // 55
```
```javascript
function sigma(n){
    if (n <= 1){
        return 1;
    }
    return n + sigma(n - 1);
}

sigma(10); // 55
```
사실 순회를 돌지 않고 해결할 수 있으면 돌지 않고 해결해야 함

시그마는 수학 공식이 있으므로 수학 공식을 이용하는게 더 효율적이다!
```javascript
function sigma(n){
    return n * (n + 1) / 2;
}

sigma(10); // 55
```
### 재귀함수로 문자열 뒤집기
```javascript
let str = ''
for (const i of 'hello'){
    str = i + str;
}
// 'olleh'
```
```javascript
function reverseString(str){
    if (str.length <= 1){
        return str[0];
    }
    return reverseString(str.slice(1)) + str[0];
    // slice()는 원본을 변경하는 메소드가 아니다
}

reverseString('hello'); // 'olleh'
```
|reverseString(str)|str.length <= 1|return|
|:---:|:---:|:---:|
|reverseString('hello')|false|reverseString('ello') + 'h'|
|reverseString('ello')|false|reverseString('llo') + 'e'|
|reverseString('llo')|false|reverseString('lo') + 'l'|
|reverseString('lo')|false|reverseString('o') + 'l'|
|reverseString('o')|true|'o'|

## [스코프](https://velog.io/@bico/JavaScript-%EB%A0%89%EC%8B%9C%EC%BB%AC-%EC%8A%A4%EC%BD%94%ED%94%84lexical-scope)
|-|var|let|const|
|:---:|:---:|:---:|:---:|
|-|var|let|const|
|scope|함수 레벨 스코프|블록 레벨 스코프|블록 레벨 스코프|
### 블록 레벨 스코프
블록 스코프 변수는 함수 밖에서 선언하면 함수 스코프 변수처럼 전역 접근할 수 있습니다. 블록 안에서 선언하면 자신을 정의한 블록과 하위 블록에서만 접근이 가능합니다.
```javascript
if (true){
    let x = 10;
    const y = 10;
}

console.log(x, y); // ReferenceError
```
```javascript
let foo = "I'm foo";
if (true){
    console.log('---');
    console.log(foo);
    let bar = "I'm bar";
    console.log(bar);
    if (true){
        console.log('---');
        console.log(foo);
        console.log(bar);
        let semin = "I'm Semin";
        console.log(semin);
    }
}
/*
---
I'm foo
I'm bar
---
I'm foo
I'm bar
I'm Semin
*/
```
```javascript
if (true){
    let foo = "I'm foo";
    console.log(foo);
    console.log(semin); // ReferenceError
    if (true){
        let semin = "I'm Semin";
    }
}
```
### 함수 레벨 스코프
함수 밖에서 선언한 함수 스코프 변수는 전역 범위를 가지고, 함수 안에서 사용하면 함수 밖을 제외한 내부 어디서든 접근이 가능
```javascript
if (true){
    var x = 10;
    var y = 10;
}

console.log(x, y); // 10 10
```
```javascript
var a = "I'm a";
function foo() {
    var b = "I'm b";
    console.log(a);        //I'm a - 전역변수. 출력가능.
    if(true) {
        var c = "I'm c";
        console.log(b);    //I'm b - 해당 함수 내 선언한 변수. 출력 가능.
    }
    console.log(c);        //I'm c - 해당 함수 내 선언한 변수. 출력 가능.
}
foo();
function bar() {
    var d = "I'm d";
    console.log(d);    //I'm d - 해당 함수 내 선언한 변수. 출력 가능.
    console.log(a);    //전역변수. 출력가능.
    console.log(b);    //해당 함수 내 선언한 변수가 아님. Error
    console.log(c);    //해당 함수 내 선언한 변수가 아님. Error
}
bar();
```
### 예제
```javascript
let x = 100;

function xplus(){
    x += 10;
}

xplus(); // undefined

x; // 110, 리턴을 안 써도 x가 변함
// let은 블록 레벨 스코프. 함수 밖에서 선언하면 전역에서 사용 가능
```
```javascript
function xplus(){
    let x = 100;
    x += 10;
}

xplus(); // undefined
x; // ReferenceError
// let은 블록 레벨 스코프. 블록 안에서 선언하면 자신을 정의한 블록과 하위 블록에서만 접근이 가능. 따라서 함수 외에서 x를 부르면 ReferenceError
```
```javascript
const x = 100;

function xplus(){
    const += 10;
}

xplus(); // Uncaught SyntaxError: Unexpected token '+='
// const는 블록 레벨 스코프. 함수 밖에서 선언했기 때문에 전역에서 접근 가능하나, 접근은 가능한데 const가 재할당이 안됨
```
## 함수 안에 함수가 있는 경우
```javascript
function a(){
    console.log('a 실행');
    function b(){
        console.log('b 실행');
    }
}

a();
// a 실행
// undefined
```
```javascript
function a(){
    console.log('a 실행');
    function b(){
        console.log('b 실행');
    }
    b();
}

a();
// a 실행
// b 실행
// undefined
b(); // Error, 함수 내의 함수가 나중에 휘발됨
```
## 화살표 함수
```javascript
function 함수1(x, y){
    return x + y;
}

let 함수2 = (x, y) => x + y;
```
```javascript
function 함수1(x, y){
    let z = x + y;
    return z;
}

let 함수2 = (x, y) => {
    let z = x + y;
    return z;
}
```
### [함수의 호이스팅](https://hanamon.kr/javascript-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85%EC%9D%B4%EB%9E%80-hoisting/)
JS의 모든 선언은 호이스팅(선언이 먼저 메모리에 저장)이 일어납니다. 그러나 let, const, class 이용한 선언문은 호이스팅이 되었지만 안된 것처럼 동작합니다. 이러한 현상은 일시적 사각지대(Temporal Dead Zone)에 빠지기 때문입니다. 

중요한 포인트는 그렇다하여 호이스팅이 안된 것은 아니라는 것입니다. 

var 키워드는 선언과 함께 undefined로 초기화됩니다. 이와 달리 let과 const는 **초기화 되지 않는 상태로** 선언만 메모리 저장됩니다.
```javascript
console.log(add(10, 20)); // 30

// mul1은 런타임 전 선언됨, 할당은 런타임에!
// 그런데 var 키워드는 선언과 함께 undefined로 초기화 됨
console.log(mul1); // undefined
// console.log(mul1(10, 20)); // not a function

// mul2는 런타임 전 선언됨(호이스팅이 일어남)
// 그런데 let 키워드는 초기화 되지 않는 상태로 선언만 메모리 저장
// console.log(mul2); // Cannot access 'mul2' before initialization

function add(x, y) {
    return x + y;
}

var mul1 = function (a, b) {
    return a * b;
};

let mul2 = function (a, b) {
    return a * b;
};
```
함수를 선언해서 사용할 것이라면 맨 위로 올려야 합니다.