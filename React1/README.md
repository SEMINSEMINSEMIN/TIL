# 중요한 예제

-   [`006_Component/my-app/src/App.jsx`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/006_Component/my-app/src/App.jsx)
    -   파일 분리
-   [`006_Component/my-app/src/구조분해할당.jsx`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/006_Component/my-app/src/%EA%B5%AC%EC%A1%B0%EB%B6%84%ED%95%B4%ED%95%A0%EB%8B%B9.jsx)
-   [`007_Hook-useState/my-app/src/App.jsx`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/007_Hook-useState/my-app/src/App.jsx)
    -   useState + 조건
    -   좋아요 버튼: 누를 때마다 스타일 변하게
-   [`008_Event/my-app/src/App.jsx`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/008_Event/my-app/src/App.jsx)
    -   로그인 / 로그아웃
    -   state 끌어올리기: 앱(여기에 useState 변수가 있음), 하위 페이지(setState 전달, 하위 페이지에서 일정 조건에서 컨트롤)
    -   로그인 된 상태에서는 홈페이지가 보임
    -   로그인이 되지 않은 상태에서는 로그인 화면이 보임
-   [`009_Component_List/my-app/src/App.jsx`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/009_Component_List/my-app/src/App.jsx)
    -   배열 내 데이터 뿌려주기
    -   리스트를 이용해 렌더링
    -   key 값
-   [`010_조건부_렌더링/my-app/src/App.jsx`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/010_%EC%A1%B0%EA%B1%B4%EB%B6%80_%EB%A0%8C%EB%8D%94%EB%A7%81/my-app/src/App.jsx)
    -   navbar 활용 가능
    -   클릭에 따라 렌더링 바꾸고 스타일 적용
-   [`011_Style/my-app/src/App copy.jsx`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/011_Style/my-app/src/App%20copy.jsx)
    -   글로벌 스타일
-   [`011_Style/my-app/src/App copy 2.jsx`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/011_Style/my-app/src/App%20copy%202.jsx)
    -   리셋 스타일
-   [`011_Style/my-app/src/App copy 3.jsx`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/011_Style/my-app/src/App%20copy%203.jsx)
    -   스타일드 컴포넌트 사용법
-   [`011_Style/my-app/src/App copy 4.jsx`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/011_Style/my-app/src/App%20copy%204.jsx)
    -   스타일드 컴포넌트: props에 따른 조건부 스타일
-   [`011_Style/my-app/src/조건부스타일함수형태.jsx`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/011_Style/my-app/src/%EC%A1%B0%EA%B1%B4%EB%B6%80%EC%8A%A4%ED%83%80%EC%9D%BC%ED%95%A8%EC%88%98%ED%98%95%ED%83%9C.jsx)
    -   스타일드 컴포넌트: 조건부 스타일의 함수 형태
-   [`011_Style/my-app/src/App copy 5.jsx`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/011_Style/my-app/src/App%20copy%205.jsx), [`011_Style/my-app/src/styled_components_확장.jsx`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/011_Style/my-app/src/styled_components_%ED%99%95%EC%9E%A5.jsx)
    -   스타일드 컴포넌트: 스타일드 컴포넌트 내려받기
-   [`011_Style/my-app/src/App.jsx`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/011_Style/my-app/src/App.jsx)
    -   css + styled-components
    -   css가 여러 스타일드 컴포넌트에서 쓰일 때 사용하기 좋을듯
-   [`011_Style/my-app/src/App copy 5.jsx`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/011_Style/my-app/src/App%20copy%205.jsx)
    -   module css
-   [`012_합성_컴포넌트/my-app/src/App copy.jsx`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/012_%ED%95%A9%EC%84%B1_%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/my-app/src/App%20copy.jsx)
    -   합성 컴포넌트 만들기
-   [`013_Router/my-app/src/App copy.jsx`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/013_Router/my-app/src/App%20copy.jsx)
    -   라우터: Component props 전달하기
-   [`013_Router/my-app/src/App copy 2.jsx`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/013_Router/my-app/src/App%20copy%202.jsx)
    -   라우터: Link
-   [`013_Router/my-app/src/App copy 3.jsx`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/013_Router/my-app/src/App%20copy%203.jsx)
    -   라우터: 파라미터 설정
-   [`013_Router/my-app/src/App copy 4.jsx`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/013_Router/my-app/src/App%20copy%204.jsx)
    -   라우터: 파라미터 설정 & useLocation
    -   게시글 등등에 활용 가능
-   [`013_Router/my-app/src/App.jsx`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/013_Router/my-app/src/App.jsx)
    -   중첩된 라우터
-   [`014_Hook-useEffect/my-app/src/App copy 2.js`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/014_Hook-useEffect/my-app/src/App%20copy%202.js)
    -   useEffect 사용법 + useState
-   [`014_Hook-useEffect/my-app/src/App copy 3.js`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/014_Hook-useEffect/my-app/src/App%20copy%203.js)
    -   카운터 만들기
    -   useEffect의 return 뒤 코드를 이용해 성능 최적화
-   [`015_Hook-useRef/my-app/src/App copy.js`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/015_Hook-useRef/my-app/src/App%20copy.js)
    -   useRef와 다른 변수들의 차이: 값을 기억한다, 렌더링 x
-   [`015_Hook-useRef/my-app/src/App.js`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/015_Hook-useRef/my-app/src/App.js)
    -   useRef를 이용해 로그인 기능
    -   useRef를 이용해 HTML 요소 접근
    -   아이디 / 비밀번호 입력 x시 해당 인풋창에 focus
        -   .current.focus();
-   [`016_Hook-useMemo/my-app/src/App copy.js`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/016_Hook-useMemo/my-app/src/App%20copy.js)
    -   useMemo를 사용하지 않아 부하가 생기는 코드
    -   해결: [`016_Hook-useMemo/my-app/src/App copy 2.js`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/016_Hook-useMemo/my-app/src/App%20copy%202.js)
-   [`016_Hook-useMemo/my-app/src/App copy 3.js`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/016_Hook-useMemo/my-app/src/App%20copy%203.js)
    -   useMemo를 사용하지 않아 인풋창에 입력할 때마다 리렌더링이 발생하는 코드
    -   해결: [`016_Hook-useMemo/my-app/src/App copy 4.js`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/016_Hook-useMemo/my-app/src/App%20copy%204.js)
        -   useState 사용시 객체를 감시하고 있을 때 주의해야할 점
        -   객체 안의 값을 아무리 바꿔도 참조하고 있는 건 객체의 값이 아니라 객체의 주소
        -   리액트는 새로운 값으로 변했다고 생각하지 않기 때문에 리렌더링이 일어나지 않는다
        -   해결법: 스프레드 기법을 이용해 새로운 객체를 만든 뒤 그걸 setState(새로운 객체) 이런식으로 해줘야 함
-   [`017_Context/my-app/src/App copy.js`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/017_Context/my-app/src/App%20copy.js)
    -   props를 객체로 전달했을 때 구조분해 방법
-   [`017_Context/my-app/src/App copy 2.js`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/017_Context/my-app/src/App%20copy%202.js)
    -   context 사용 방법: props를 통하지 않고 전달
-   [`017_Context/my-app/src/App.js`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/017_Context/my-app/src/App.js)
    -   Context.Provider로 전달 값 변경
-   [`018_Hook-useContext/my-app/src/App copy.js`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/018_Hook-useContext/my-app/src/App%20copy.js)
    -   Context API에서 Context.consumer로 전달하던 방식을 Hooks의 useContext를 사용해서 더 편하게 값을 전달할 수 있다.
    -   함수형 컴포넌트에서만 사용 가능
-   [`018_Hook-useContext/my-app/src/App.js`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/018_Hook-useContext/my-app/src/App.js)
    -   파일 분리시 useContext 사용법
-   [`020_useState-Lazy-initialize/my-app/src/App copy.js`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/020_useState-Lazy_initialize/my-app/src/App%20copy.js)
    -   lazy initialize를 하지 않았을 때 문제점
    -   해결법: [`020_useState-Lazy-initialize/my-app/src/App.js`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/020_useState-Lazy_initialize/my-app/src/App.js)
-   [`020_useState-Lazy-initialize/my-app/src/App copy 2.js`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/020_useState-Lazy_initialize/my-app/src/App%20copy%202.js)
    -   lazy initialize: setState하는 방법
-   [`021_Functional_Hook_Flow/my-app/src/App.js`](https://github.com/SEMINSEMINSEMIN/TIL/tree/main/React1/021_Functional_Hook_Flow/my-app)
    -   함수형 Hook Flow
    -   [useLayoutEffect vs useEffect](#2122-레이아웃-이펙트란)
    -   마운트, 업데이트, 언마운트별로 동작 다르게 하기
-   [`022_Custom_Hook/my-app/src/App.js`](https://github.com/SEMINSEMINSEMIN/TIL/blob/main/React1/022_Custom_Hook/my-app/src/App.js)
    -   Custom Hook - 반복되는 Hook 재사용 위함

# 4. JSX

## 4.1. 기초

-   JSX: JavaScript + XML

## 4.2. JSX 문법

### 4.2.1 최상위 부모요소는 1개

### 4.2.2 주석

### 4.2.3 태그에 클래스 넣기 + 스타일 적용하기

-   클래스 정의: className
-   in-line 스타일 적용

    ```html
    <div style={{backgroundColor:"black", color:"white"}}></div>
    ```

    -   객체 형태로 정의
    -   camelCase(단어를 대문자로 구분): .css 파일을 만들어 사용할 때에는 그대로 사용

### 4.2.4 자바스크립트 사용하기

-   중괄호 내 JavaScript 문법 사용 가능
    -   App copy 2.jsx 참고

## 4.3. 실습 과제

-   App.jsx, app.css 참고

## 참고

-   [JSX 좀 더 알아보기](https://paullabworkspace.notion.site/JSX-9a4ef8f7cecb406e8d2be2ff9383706f)
    -   props는 **리액트 컴포넌트를 사용하며 정의한 어트리뷰트들**이 모여있는 객체
        ![](https://paullabworkspace.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1e05956b-f5de-4fac-ad6e-5948beee9393%2FUntitled.png?table=block&id=85f8ed17-cbf2-42a6-84ad-edb4cc6e7a39&spaceId=579fe283-28aa-489d-ae65-d683304becfc&width=2000&userId=&cache=v2)

# 5. Fragment

## 5.1. 시맨틱한 마크업을 방해하는 요소

## 5.2. Fragments

-   Fragments 사용시 <div>와 같은 별도의 노드를 추가하지 않고 여러 개의 자식을 감싸줄 수 있다.
-   방법 1: App copy.js 참고

    ```js
    import React, { Fragment } from "react";

    function App() {
        return (
            <React.Fragment>
                <h1>안녕, 라이캣 1호!</h1>
                <h1>안녕, 라이캣 2호!</h1>
            </React.Fragment>
        );
    }
    ```

-   방법 2: App.js 참고
    ```js
    function App() {
        return (
            <>
                <h1>안녕, 라이캣 1호!</h1>
                <h1>안녕, 라이캣 2호!</h1>
            </>
        );
    }
    ```

## 5.3. Fragment 사용 비교

# 6. Component 만들기

App.jsx와 Components 폴더 참고

## 6.1. 컴포넌트 만들기

-   컴포넌트 이름을 지을 때 첫 글자는 대문자

## 6.2. Props 파라미터

## 6.3. 컴포넌트 파일 분리

-   파일 분리시 가장 윗줄에 `import React from 'react`를 입력.
    -   명시적으로 'react를 사용하겠다'라고 선언한다고 보면 됨

## 6.4. Quiz

## 6.5. 참고사항

### 6.5.1. 구조 분해 할당을 통한 props 전달

-   구조분해할당.jsx, 구조분해할당1.jsx 참고

# 7. Hook - useState

## 7.1. 컴포넌트에 변하는 데이터 넣고 싶어요.

-   모든 변수가 변할 때마다 컴포넌트를 업데이트 한다면 많은 리소스 낭비됨
-   특정 변수를 지정하여 그 변수가 변할 때마다 페이지를 업데이트 하라는 명령을 내려줘야 한다.

## 7.2. useState 사용해보기

```js
import React, { useState } from "react";
```

-   useState: 변수의 값이 변경될 때마다 페이지를 업데이트 하도록 만들어주는 것
-   setState를 통해 값이 변경될 때 리액트는 자동으로 해당 '컴포넌트'를 다시 렌더링해준다.

## 7.3. Quiz

# 8. React에서 이벤트 처리하기

## 8.1. DOM 이벤트와의 차이점

```js
function Resume(props) {
  const [like, setLike] = useState(0);

  function handleClickEvent() {
    setLike(like + 1);
  }

  return (
    <button onClick={handleClickEvent}>like</button> <span>{like}</span>
  );
}
```

-   React의 이벤트는 카멜케이스 사용
-   React는 JSX를 사용하여 함수로 이벤트 핸들러를 전달
    -   이벤트 관련 함수는 앞에 handle을 붙여주는 것이 관례!: App copy 2.jsx 참고

## 8.2. 리액트에서 지원하는 이벤트 종류

-   onClick: App copy 2.jsx
-   onChange: App copy 5.jsx, App copy 7.jsx(로그인), App.jsx(로그인 & 끌어올리기 - 로그인시 로그아웃시 화면 전환)
-   onInput:
-   onFocus
-   onMouse: App copy 3.jsx, App copy 4.jsx
-   onLeave: App copy 3.jsx, App copy 4.jsx
-   onSubmit: App copy 5.jsx, App copy 7.jsx(로그인), App.jsx(로그인 & 끌어올리기 - 로그인시 로그아웃시 화면 전환)
-   기타: https://ko.reactjs.org/docs/events.html#other-events

# 9. 컴포넌트 리스트 만들기

## 9.1. 컴포넌트 리스트의 필요성

코드가 반복되고 있음

```js
import "./App.css";

function App() {
    return <Hello name="licat" />;
}

function Hello(props) {
    const name = props.name;

    return (
        <div>
            <h1>안녕, {name} 1호</h1>
            <h1>안녕, {name} 2호</h1>
            <h1>안녕, {name} 3호</h1>
            <h1>안녕, {name} 4호</h1>
            <h1>안녕, {name} 5호</h1>
            <h1>안녕, {name} 6호</h1>
            <h1>안녕, {name} 7호</h1>
            <h1>안녕, {name} 8호</h1>
            <h1>안녕, {name} 9호</h1>
            <h1>안녕, {name} 10호</h1>
        </div>
    );
}

export default App;
```

## 9.2. 컴포넌트 리스트 만들기

-   컴포넌트 안에서 리스트를 렌더링 할 때는 꼭 key값을 넣어줘야 한다.
    -   이유: 리액트에서 렌더링 작업을 진행할 때 어떤 요소에 변동이 있다면 그 요소만 새로 그려주기 위함.
    -   키가 없는 경우: App copy.jsx, 콘솔창을 열어보면 경고가 뜸
    -   키가 있는 경우: App copy 2.jsx
-   일반적으로 배열의 id 값을 넣어준다. 고유의 값을 찾을 수 없다면 인덱스를 key로 사용하면 되지만 나중에 순서와 관련된 문제가 생길 수 있기 때문에 권장 x
-   key 값은 **동일한 컴포넌트 리스트**에서만 '유일값'이면 된다.

## 9.3. 컴포넌트 리스트를 직접 만들어보기

-   App copy 3.jsx

## 9.4. 연습문제

# 10. 조건부 렌더링

## 10.1. 조건에 따라 다른 페이지 렌더링

## 10.2. 나아가기

-   삼항 연산자
-   단락 회로 평가

    ```js
    true && <h1>hello world</h1> -> h1 출력
    false && <h1>hello world</h1> -> false 출력
    true || <h1>hello world</h1> -> true 출력
    false || <h1>hello world</h1> -> h1 출력

    // 예시
    newMail.length > 0 && <h1>읽지 않은 메일이 있습니다.</h1> -> h1 출력
    ```

# 11. 스타일 적용하기

## 11.1. styled-components

설치 방법

```
npm install styled-components
```

### 11.1.1. 글로벌 스타일 만들기

-   최상위 컴포넌트(App.js) 상단에 추가하면 **모든 하위 컴포넌트**에 스타일이 적용된다.

    ```js
    import { createGlobalStyle } from "styled-components";
    ```

-   App copy.jsx

### 11.1.2. Reset css

-   설치 방법

    ```
    npm i styled-reset
    ```

*   글로벌 스타일에 styled-reset 적용

    ```js
    import { createGlobalStyle } from "styled-components";
    import reset from "styled-reset";

    const GlobalStyle = createGlobalStyle`
      ${reset}
    `;
    ```

*   App copy 2.jsx

### 11.1.3. styled-components를 사용한 스타일 적용

-   불러오기

    ```js
    import styled from "styled-components";
    ```

*   App copy 3.jsx

### 11.1.4. props에 따른 조건부 스타일

-   App copy 4.jsx

### 11.1.5. 다양한 문법 활용

-   CSS 확장
    -   App copy 5.jsx: 스타일드 컴포넌트 내려 받기
    -   App.jsx: css + styled-components

## 11.2. module.css

-   index.js에 index.css를 import하면 전역으로 CSS가 적용된다. App.js에 app.css를 import하면 App 컴포넌트에 들어있는 모든 컴포넌트에 적용된다.

    ![](https://paullabworkspace.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff40568e5-5a88-4b40-abd7-b7331cd0ee7e%2FUntitled.png?table=block&id=a117fa1e-1353-4d81-806c-d55ca067d724&spaceId=579fe283-28aa-489d-ae65-d683304becfc&width=490&userId=&cache=v2)

-   부모 컴포넌트에서 import한 css는 자식까지 자동으로 적용되고, 자식 컴포넌트에 새로 css를 적용하게 되면 부모의 스타일은 무시되고 자식 컴포넌트에 import된 스타일이 적용된다.

### 11.2.1. 일반 CSS일 때

-   해당 컴포넌트가 아닌 상위나 하위 컴포넌트에 영향을 줄 수 있다.

### 11.2.2. module.css일 때

-   자동으로 클래스명이 겹치지 않도록 처리해준다.

-   주의할 점: 적용하고자 하는 컴포넌트 이름과 반드시 일치시켜줘야 한다.
    -   Detail.jsx 파일에만 적용해주고 싶은 module.css의 파일명은 Detail.module.css여야 한다.

## 11.3. Quiz

## 11.4. 참고

### 11.4.1. styled components의 확장

-   `styled_components_확장.jsx`

### 11.4.2. 조건부 스타일의 함수 형태

-   `조건부스타일함수형태.jsx`

# 12. 합성 컴포넌트

-   일반적인 컴포넌트를 하나 만들고 그 안에 세부 기능을 가지는 컴포넌트를 합성
    ![](https://paullabworkspace.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F72577288-6817-4121-a411-372329f9649c%2FUntitled.png?table=block&id=b15179d0-2a31-489e-9593-0275a156661a&spaceId=579fe283-28aa-489d-ae65-d683304becfc&width=1470&userId=&cache=v2)
    ![](https://paullabworkspace.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F5e4de7f2-1ab5-4e43-a813-224ed51eea87%2FUntitled.png?table=block&id=637b7dc0-db50-4245-9b71-8106e5ff9e8a&spaceId=579fe283-28aa-489d-ae65-d683304becfc&width=670&userId=&cache=v2)
-   컴포넌트 사이에 들어가는 자식요소를 props.children으로 받아온다.
    -   App copy.jsx

# 13. React Router

## 13.1. 설치하기

```
npm install react-router-dom
```

## 13.2. BroserRouter, Routes, Route

```
import { BrowserRouter, Routes, Route } from "react-router-dom";
```

### 13.2.1. Component props 전달하기

-   App copy.jsx

### 13.2.2 Link

-   link는 주소만 바꿀 뿐, 페이지를 새로 불러오지 않는다.
-   Link 작성법

    ```js
    // Link 작성하는 방법

    // 문자열
    <Link to="/courses?sort=name&sorting=asc" />

    // 객체
    <Link
      to={{
        pathname: "/courses",
        search: "?sort=name&sorting=asc",
        hash: "#the-hash",
        state: { fromDashboard: true }
      }}
    />
    ```

-   a 태그 대신 link 사용 이유
    -   a 태그: 클릭시 href에 설정해준 경로 이동과 동시에 페이지를 새로 불러오기 때문에 페이지 새로고침
    -   Link: HTML5 History API를 이용해 브라우저의 주소만 바꾸기 때문에 페이지를 불러오지 않고 dom만 조작해서 페이지를 보여줌
-   App copy 2.jsx

### 13.2.3. 파라미터 설정

-   App copy 3.jsx
-   App copy 4.jsx

### 13.2.4. 중첩된 Router

-   App.jsx

## 13.3. Quiz

-   퀴즈.jsx

*   **Home Page :** /
*   **Product Detail Page** : /products/:id
    -   ex) /products/1 , /products/2, /products/3, /products/4
*   **Product Detail Notice Page :** /products/:id/notice
    -   ex) /products/1/notice , /products/2/notice…
*   **Cart Page :** /cart
*   **Coupon Page :** /users/coupon
*   **Question Page :** /users/question
*   **Notice Page :** /users/notice
*   **User Page :** /users

## 13.4. 추가 연습문제

# 14. Hook - useEffect

## 14.1. 간단한 카운터 만들기

-   App copy 3.js

## 14.2. useEffect

-   state를 지정하여 해당 스테이트가 변경되었음을 감지하면 함수를 실행함
-   useEffect 구조

    ```js
    useEffect(()=>{
        // state가 변경되어 렌더링 될 때 실행하는 부분!
        // 공부하려고 책 펴는 타이밍!
        return()=>{
        // 다시 렌더링을 하기 이전에 컴포넌트를 지우고 다시 그리겠죠?
        // 이 과정에서 지우기 전에 실행되는 부분입니다! clean-up이라고도 하죠.
        // 여러분들 시험 공부 하나를 마치고 다음 시험 공부 전에 책상 정리하는 느낌이랄까요..
        }
    },[/*state값이 들어갑니다.(들어가지 않으면 최초 1번만 실행됩니다.*/)])
    ```

-   useEffect의 형태

    ```js
    // 컴포넌트가 업데이트 될 때마다 매번 실행
    useEffect(()=>{
        console.log('hello world');
    })

    // 처음에만 실행
    useEffect(()=>{
        console.log('hello world');
    }, [])

    // 변수들의 변화가 일어날 때마다 실행
    useEffect(()=>{
        console.log('hello world');
    }, [변수1, 변수2...])
    ```

## 14.3. Quiz

# 15. Hook - useRef

-   useRef는 순수 자바스크립트 객체를 생성한다.
    ```js
    const refContainer = useRef(initialValue);
    // 값의 접근: refContainer.current
    ```
-   사용 용도
    -   렌더링과 상관없이 값을 변경하고 싶을 때
    -   컴포넌트의 태그에 직접 접근하고 싶을 때, useRef를 이용해 useRef가 접근한 태그 요소의 값을 바꿀 때는 리렌더링을 발생하지 않는다.
-   남용하지 말것
-   ref는 전역으로 작동하지 않고 컴포넌트 내부에서만 작동한다.

## 15.1. useRef

## 15.2. useRef와 다른 변수들의 차이

-   App copy.js

## 15.3. useRef를 사용하지 않은 방식

-   App copy 2.js

## 15.4. useRef 사용해 봅시다!

# 16. useMemo

-   useMemo를 사용하지 않아 부하가 생기는 코드: App copy.js
    -   해결: App copy 2.js
-   useMemo를 사용하지 않아 인풋창에 입력할 때마다 리렌더링이 발생하는 코드: App copy 3.js
    -   해결: App copy 4. js

## 16.1. useMemo란

-   state가 있는 컴포넌트에 state **변화가 생기면** 재평가 후 새로 렌더링
-   컴포넌트 성능 최적화
-   memoization
    -   재귀함수의 피보나치 순열: 많은 함수 반복 -> 결과값을 object에 가지고 있다면 반보갈 필요가 없다.
    -   부하가 생기는 함수를 반복해서 작업할 때 기억해두었다가 사용하는 기법
    -   렌더링이 될 때 이전에 작업해두었던 결과값을 가지고 있다가 반영해준다.
-   사용법

    ```js
    const 저장할변수 = useMemo(() => {
        return 계산하는_무거운함수();
    }, [감시하고_있는_변수]);
    ```

*   가상 돔
    -   최초 렌더링
    -   이전 렌더링 부분에 가상 돔 저장
    -   상태 업데이트
    -   상태 업데이트로 인한 가상 돔 렌더링
    -   업데이트로 인해 가상 돔과 이전에 만들어진 가상 돔 비교
    -   바뀐 부분 브라우저에 렌더링

## 16.2. useMemo와 useEffect 차이

-   useMemo: 렌더링 전에 실행되어 메모이제이션한 것을 반환
-   useEffect: 렌더링 후에 일어난다.
-   useMemo는 렌더링에 직접적인 영향을 미칠 수 있다. -> 리렌더링이나 불필요한 재실행 과정을 막는 방법에 사용하기 적합
-   반면 useEffect는 렌더링한 이후에 동작하기 때문에 리렌더링을 방지하지 못한다. -> useEffect는 상태를 이용한 관리에 사용됨

# 17. Context (Context API)

![](https://paullabworkspace.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ffb42f9bb-0642-4781-bf42-8401ae811fde%2FUntitled.png?id=aed12f56-b295-43a9-9bef-fde85061be61&table=block&spaceId=579fe283-28aa-489d-ae65-d683304becfc&width=2000&userId=&cache=v2)

-   context는 props를 사용하지 않고 데이터를 전달하도록 해준다.
-   props에 대한 **전역** 데이터 저장소

## 17.1. props와 context

## 17.2. contextAPI

# 18. Hook - useContext

-   Context API에서 Context.consumer로 전달하던 방식을 Hooks의 useContext를 사용해서 더 편하게 값을 전달할 수 있다.
-   함수형 컴포넌트에서만 사용 가능하다.

## 18.1. useContext 적용하기

## 18.2. useContext 자손 컴포넌트에 적용하기

## 18.3. 파일이 분리되어 있을 경우

# 20. useState - Lazy initialize

-   useState를 사용하여 state를 초기화하는 과정을 lazy하게 하는 것.
-   useState에 함수가 실행한 결과를 값으로 넘기지 않고 함수 자체를 넘김
    -   최초 초기화 진행 과정에서 함수 실행
    -   이후 업데이트에서 초기화가 진행되지 않는다면 함수를 실행하는 부분이 생략됨

# 21. Functional Component - Hook Flow

## 21.1. 함수형 컴포넌트의 라이프사이클

-   함수형 컴포넌트에서는 라이프 사이클 메서드를 직접적으로 사용하지 않는다.
-   Hook을 통해 class를 작성하지 않고 state와 같은 React의 기능들을 사용할 수 있게 되면서 함수형 컴포넌트를 훨씬 편하게 사용할 수 있게 되었다.

## 21.2. Hook Flow: 공식 명칭 x

![](https://paullabworkspace.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F56bfc5b2-af1a-4924-8324-b37c6830cee0%2FUntitled.png?id=909221d9-7587-43cc-b0d1-9fe2e56d8404&table=block&spaceId=579fe283-28aa-489d-ae65-d683304becfc&width=1250&userId=&cache=v2)

### 21.2.1. 상세 내용

-   Run lazy initializers: 컴포넌트가 만들어질 때, props, state 등의 값을 초기화
-   Render: 리액트 DOM 렌더
-   React updates DOM: 렌더링된 DOM과 기존 DOM을 기반으로 업데이트
-   Cleanup LayoutEffects: 업데이트/언마운트 과정에서 실행. 업데이트 과정에서는 Run LayoutEffects 이전, 언마운트 과정에서는 컴포넌트가 제거되기 전에 진행된다.
-   Run LayoutEffects: 마운트/업데이트 과정에서 컴포넌트가 브라우저에 그려지기 전에 동작
-   Browser paints screen: 만들어진 React DOM들을 브라우저에 그려줌
-   Cleanup Effects: 업데이트/언마운트 과정에서 실행. Run Effects 이전, 언마운트 과정에서는 컴포넌트가 제거되기 전에 진행
-   Run Effects: 마운트/업데이트 과정에서 컴포넌트가 브라우저에 그려진 후 동작

### 21.2.2. 레이아웃 이펙트란?

https://merrily-code.tistory.com/46

-   레이아웃 이펙트: 브라우저가 화면에 DOM을 그리기 전에 이펙트 수행
-   useEffect: DOM이 화면에 그려진 이후에 호출

# 22. Custom_Hook

## 22.1. Custom Hook이란?

-   중복되는 Hook을 커스터마이징해서 분리하고 재사용하는 방법
